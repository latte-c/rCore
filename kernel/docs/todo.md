# 关于rCore Tracing & eBPF的TODO事项

这里记录了关于rCore内核追踪和eBPF尚未实现的特性。

## 追踪数据源

### 动态追踪

目前的动态追踪机制有kprobes。如果你想追踪用户程序，可以考虑实现uprobes。

### 静态追踪

对Rust的async function的追踪缺少编译器支持，短期内实现比较困难。对此的替代方案是加入静态追踪点，比如系统调用入口和出口。最好能有统一静态追踪点和动态追踪点的机制。

## eBPF

### 验证器

缺失。可以考虑集成一个。

### 解释器

缺失。其实有现成的，但是没有集成。

### JIT编译器

缺少对原子操作指令和大小端转换指令的支持。不支持riscv64以外的架构。

### 系统调用

目前只实现了`bpf(2)`的几个子功能。

1. 未实现较为标准（相较Linux）的BPF程序加载

当然，现在已经有了`BPF_PROG_LOAD_EX`子命令，这不是什么太困难的事情。

2. 缺少`BPF_PROG_DETACH`

Linux文档中未详细描述具体行为，可以参照Linux源码实现。

3. 未实现`close(2)`销毁BPF程序或BPF Map的功能

Linux关于`bpf(2)`的文档中指出，进程退出时应当释放创建的BPF程序和BPF Map，并且可以通过`close(2)`系统调用主动释放上述BPF对象。目前的实现中两种BPF对象尚未与进程的文件描述符表建立关联，它们使用全局唯一的“文件描述符”标识。

### Helper Functions

只实现了BPF Map交互和追踪相关的几个最简单的辅助函数。

+ `bpf_trace_printk`的实现不标准，应当有printf风格的格式化控制。未对格式化字符串的地址进行检查。
+ `bpf_probe_read`的行为未定义。可能造成危险后果。
+ `bpf_get_prandom_u32`未实现。
