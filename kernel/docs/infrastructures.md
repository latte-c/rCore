# rCore基础设施

这里介绍了一些与内核追踪相关的rCore基础设施。

## 内核模块

**警告**：这部分内容与Rust编译器版本紧密相关。这里所有讨论限定于**nightly-2020-08-04**。

原本功能由gjz010实现，支持的架构包括x86_64和AArch64，我们将其移植到了riscv64平台上并修复了编译问题。

与Linux内核模块类似，rCore内核模块使得开发者能够在不修改内核主体代码的前提下实现和测试新的内核功能，它们可以直接引用rCore主体中的公开代码。其优点在于相对独立和轻量，例如我们希望测试自己给内核添加的功能或者追踪内核函数，重新编译rCore的速度会比较慢，而且可能引入后续用不着的代码。若将其实现在内核模块中就会方便许多：编译速度快，不污染内核。

但是受限于Rust编译器和构建工具，rCore内核模块也有较多的限制。最大的问题在于内核模块不能独立于rCore编译，内核模块的编译必须依赖rCore的编译产物，这意味着必须先编译rCore才能编译内核模块，而且两者的rustc版本必须一致。另外的限制与RISC-V架构有关，但我们用了一些trick绕过了部分限制。

事实上，内核模块应当是位置无关代码，内核承担了对其重定位和链接的职责。对于riscv64架构，内核模块构建时的配置（/kernel/targets/riscv64.json）应有`"relocation-model": "pic"`。但是内核主体使用的`relocation-model`为`static`，而且rCore与内核模块编译必须使用同一配置文件（使用不同配置文件会被当做不同架构，无法编译），解决方案是编译内核模块时把`static`改成`pic`，编译完再改回去。内核模块构建过程的最后一步是将目标文件链接为shared object，对于riscv64架构应当使用`riscv64-linux-musl`工具链而不是`riscv64-unknown-elf`工具链，后者主要面向嵌入式平台而不支持生成shared object。

## 符号表

在内核模块相关代码中包含了对内核符号表的处理。现有的处理方式比较粗暴：数据段中为内核符号表预留了约1M的空间，构建内核时脚本通过`nm`得到内核符号信息，对其压缩后注入至内核映像为其预留的空间中。rCore初始化期间将解压并解析自身的符号信息。

有了符号表，内核的追踪和调试能变得更方便。对于kprobes，上层使用时通常都不会直接提供目标地址，而是目标函数名，现在内核可以通过函数名获得对应地址。此外，栈回溯时也可以直接获得调用栈中的函数信息（函数名），此功能可通过在有序符号地址中二分查找目标pc实现。
